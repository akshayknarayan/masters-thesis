\chapter{Introduction}
Congestion control, a class of algorithms that decide when endpoints should send each segment of data, has been active area of development since the the 1980s.
Research has flourished recently, due to new applications and network technologies.
This research both includes new algorithms, such as Remy~\cite{remy}, Copa~\cite{copa}, as well as new \textit{datapaths}, a term referring to any module that allows applications to interface with the network; i.e., send and receive packets.

\par Currently, congestion control is tightly integrated into the datapath itself - a natural place to make decisions about how fast to send data is in the datapath.
Example datapaths include the Linux kernel, which implements various congestion control algorithms, kernel bypass methods, such as mTCP/DPDK ~\cite{dpdk,mtcp,netmap}, specialized Network Interface Cards (``Smart NICS''~\cite{smartnic}).
One recent datapath is QUIC~\cite{quic}, a UDP based transport, currently used in Google chrome and YouTube connections.
However, congestion control algorithms do not \textit{need} to be implemented directly in the datapath.
In fact, implementing congestion control in an off-datapath agent, that communicates with the datapath at regular intervals, would even ease congestion control development.

\par If algorithms were implemented through some common off datapath agent, any datapath that supports this agent could run the resulting algorithms.
This would introduce ``write once, run anywhere'' behavior - where developers could write congestion control algorithms once, through this agent, and run them automatically on multiple datapaths.
The recently proposed Congestion Control Plane (CCP)~\cite{ccp} architecture presents a design for a possible off datapath congestion control agent.
This thesis explores what are the core responsibilities of datapaths to support various congestion control algorithms.
We design a datapath API for datapaths to support CCP, and we use QUIC as a case study.

\section{Motivation for a Congestion Control Plane}
While various new congestion control algorithms have emerged, as well as many new datapaths, new datapaths tend to lack support for various congestion control algorithms.
There are many subtle nuances in ensuring the correctness of behavior and performance of a new algorithm on a \textit{single} datapath.
With an architecture like CCP's, congestion control researchers can focus on the core algorithm logic without worrying about  deploying the algorithm on various datapaths.
CCP enables faster congestion control development; with a simple userspace API to implement a new algorithm, developers can iterate on mistakes faster.
It enables new capabilities - with a single off datapath agent controlling congestion avoidance for multiple flows at the same endpoint, CCP could additionally provide an aggregator that controls multiple flows at once.
Though this is not a problem for the QUIC datapath, which is in userspace, the Linux kernel datapath is limited in computation in that algorithms cannot perform floating point operations.
Algorithms implemented in CCP can use complex calculations such as fast fourier transforms~\cite{nimbus} or neural networks~\cite{indigo}.
Finally, CCP enables developers to automatically run the same algorithm on different datapaths with minimal effort.

\section{Why QUIC?}
We explore building CCP datapaths with QUIC as a case study.
\section{Designing CCP Datapaths}
Congestion control algorithms, at their core, decide when to transmit each segment of data by using measurements, or \textit{congestion signals} taken after sending previous segments of data.
For congestion control to be off the datapath, the datapath must summarize information about these congestion signals - such as RTT, packets lost and received, explicit congestion notification (ECN) markings, sending and receive rate, and provide it to the off datapath agent at certain intervals.
The datapath must also expose an interface to control sending rates - namely an interface to set the congestion window or pacing rate for the connection.

\section{Contributions}
This thesis makes the following contributions:
\begin{itemize}
    \item Designing a common shared library, \libccp, that contains an API for datapaths to easily support CCP. \footnote{This portion of the work was done jointly with my collaborators on our CCP paper, to be published at SIGCOMM 2018.} This includes distilling the congestion control requirements for a datapath. \libccp is available at \url{https://github.mit.edu/nebula/libccp}
    \item A case study of using \libccp to design a new CCP datapath inside QUIC, and an evaluation of the fidelity of this QUIC datapath: is the performance reasonable? Does the API give congestion control developers the same flexibility as the QUIC pluggable congestion control interface? This implementation is available at \url{https://github.mit.edu/nebula/ccp-quic}.
    \item A comparison of various congestion control algorithms (new and old) running on both the Linux datapath and QUIC, through CCP. This includes various algorithms that have never been run over TCP or QUIC before, such as Remy, and Nimbus.
\end{itemize}





